package org.cloudio.morpheus.chat

import java.util.concurrent.atomic.AtomicLong

import org.morpheus.{wrapper, dimension, fragment}
import org.morpheus.Morpheus._
import org.morpheus.{SuperBase, DefaultCompositeStrategy, MutableMorphMirror}

/**
*
* Created by zslajchrt on 18/03/15.
*/
class Contacts {

}

// MODEL

trait ContactTypes {

  type ContactType <: Contact

  def createContact(id: Option[Long]): ContactType

  // todo: it could be generated by a macro
  implicit def specialize(contact: Contact): ContactType = contact match {
    case c: ContactType => c
    case _ =>
      // this should never be called
      val spec = createContact(Some(contact.id))
      spec.adopt(contact)
      spec
  }

}


trait ContactConfig {
  val id: Long
}

object ContactConfig {
  def apply(contactId: Long) = new ContactConfig {
    override val id: Long = contactId
  }
}

@fragment
trait Contact extends ContactConfig {
  var name: String = _
  var email: String = _

  def adopt(other: Contact): Unit = {
    name = other.name
    email = other.email
  }
}

trait ContactListConfig {
  val ownerId: Option[Long]
}

object ContactListConfig {
  def apply() = new ContactListConfig {
    override val ownerId = None
  }

  def apply(owner: Long) = new ContactListConfig {
    override val ownerId = Some(owner)
  }
}

trait ContactListOwnerLoader {
  this: ContactTypes =>

  def loadOwner(ownerId: Option[Long]): ContactType

}

@fragment
trait ContactList extends ContactListConfig {

  this: ContactTypes with ContactListOwnerLoader =>

  lazy val _owner: ContactType = loadOwner(ownerId)
  protected var _contacts: List[ContactType] = Nil

  def owner: ContactType = _owner

  def contacts: List[ContactType] = _contacts

}


// PERSISTENCE

trait ContactPersistenceConfig {
  def contactsDAO: ContactsDAO
}

object ContactPersistenceConfig {
  def apply(contDAO: ContactsDAO) = new ContactPersistenceConfig {
    override def contactsDAO: ContactsDAO = contDAO
  }
}

@fragment
trait ContactPersistence extends ContactPersistenceConfig {

  this: Contact =>

  def persist(): Unit = {
    contactsDAO.updateContact(this)
  }

  def refresh(): Unit = {
    contactsDAO.refreshContact(this)
  }
}

@fragment
trait ContactListPersistence extends ContactListOwnerLoader {

  this: ContactTypes with ContactList with ContactsDAO =>

  override def loadOwner(ownerId: Option[Long]): ContactType = {
    loadContact(ownerId)
  }

  def loadContacts(): Unit = {
    _contacts = loadAllContacts(_owner)
  }

  def addToContactList(newContact: ContactType): ContactType = {
    addToContactList(owner, newContact)
    _contacts ::= newContact
    newContact
  }

  def removeFromContactList(contact: ContactType): Unit = {
    removeFromContactList(owner, contact)
    _contacts = _contacts.filter(_.id != contact.id)
  }
}

trait Presentable {
  def present: String
}

trait Validating {
  def isValid: Boolean
}

@fragment
trait PrettyPrintedContactList extends Presentable {
  this: ContactList with HasPrettyPrintedContact =>

  //def present: String = s"ContactList: ${contacts.mkString(",")}"
  def present: String = {
    s"ContactList: ${contacts.map(_.present).mkString(";")}"
  }

}

@fragment
trait ValidatingContactList extends Validating {
  this: ContactList with HasValidatingContact =>

  override def isValid: Boolean = contacts.forall(_.isValid)
}

@fragment
trait PrettyPrintedContact extends Presentable {
  this: Contact =>

  def present: String = s"{id=$id, name=$name, email=$email}"
}

@fragment
trait ValidatingContact extends Validating {
  this: Contact =>

  def isValid: Boolean = {
    // todo
    true
  }
}

// DAO for the contacts
//@dimension()
trait ContactsDAO {

  type ContactType <: Contact

  def initContactPersistence(): Unit

  def loadAllContacts(owner: ContactType): List[ContactType]

  def addToContactList(owner: ContactType, newContact: ContactType): Unit

  def removeFromContactList(owner: ContactType, contact: ContactType): Unit

  def loadContact(id: Option[Long]): ContactType

  def updateContact(contact: Contact): Unit

  def refreshContact(contact: Contact)
}

class ContactsDAO$dimension extends SuperBase[ContactsDAO] with ContactsDAO {

  outer =>

  private def sup = $super$.asInstanceOf[ContactsDAO {type ContactType = outer.ContactType}]

  override def loadAllContacts(owner: ContactType): List[ContactType] = sup.loadAllContacts(owner)

  override def initContactPersistence(): Unit = sup.initContactPersistence()

  override def updateContact(contact: Contact): Unit = sup.updateContact(contact)

  override def removeFromContactList(owner: ContactType, contact: ContactType): Unit = sup.removeFromContactList(owner, contact)

  override def loadContact(id: Option[Long]): ContactType = sup.loadContact(id)

  override def refreshContact(contact: Contact): Unit = sup.refreshContact(contact)

  override def addToContactList(owner: ContactType, newContact: ContactType): Unit = sup.addToContactList(owner, newContact)
}

// MOCK PERSISTENCE

// todo: This is very important! It allows us to specialize the composite type by overriding the abstract type member
trait HasPrettyPrintedContact {
  type ContactType <: Contact with PrettyPrintedContact
}

trait HasValidatingContact {
  type ContactType <: Contact with ValidatingContact
}

@fragment
trait MockContactTypes extends ContactTypes with HasPrettyPrintedContact with HasValidatingContact {
  this: ContactsDAO =>

  val contactModel = parse[Contact with PrettyPrintedContact with ValidatingContact with ContactPersistence](true)
  type ContactType = contactModel.MutableLUB

  private val idGen = new AtomicLong()

  def createContact(id: Option[Long]): ContactType = {
    implicit val contactConfig = single[Contact, ContactConfig](ContactConfig(id.getOrElse(idGen.getAndIncrement)))
    implicit val contactPersConfig = single[ContactPersistence, ContactPersistenceConfig](ContactPersistenceConfig(this))
    val contactComp = singleton(contactModel, DefaultCompositeStrategy(contactModel))
    contactComp.make_~
  }

}

//trait MockContactTypesStatic extends ContactTypes with HasPrettyPrintedContact with HasValidatingContact {
//  //val contactModel = parse[Contact with PrettyPrintedContact with ValidatingContact with ContactPersistence with MockContactsDAO](true)
//  type ContactType = Contact with PrettyPrintedContact with ValidatingContact with ContactPersistence with MockContactsDAO with MockContactTypesStatic
//
//  private val idGen = new AtomicLong()
//
//  def createContact(idOpt: Option[Long]): ContactType = new Contact with PrettyPrintedContact with ValidatingContact with ContactPersistence with MockContactsDAO with MockContactTypesStatic {
//    override val id: Long = idOpt.getOrElse(idGen.getAndIncrement)
//
//  }
//
//}

trait MockContactsDAOConfig {
  type ContactType <: Contact
}

@fragment
trait MockContactsDAO extends ContactsDAO {

  this: ContactTypes =>

  private var contacts: Map[Long, ContactType] = Map.empty
  private var contactLists: Map[Long, List[Long]] = Map.empty

  def initContactPersistence() {
    // create the initial contacts
    loadContact(None)
    loadContact(None)
    loadContact(None)
    contactLists += (0l -> List(1l, 2l))
  }

  def loadAllContacts(owner: ContactType): List[ContactType] = contactLists.get(owner.id) match {
    case None => Nil
    case Some(cl) => cl.map[ContactType, List[ContactType]](contacts(_))
  }

  def refreshContact(contact: Contact): Unit = {
    contacts.get(contact.id) match {
      case None => sys.error(s"Missing contact ${contact.id}")
      case Some(persistentContact) =>
        contact.adopt(persistentContact)
    }
  }

  def updateContact(contact: Contact): Unit = {
    contacts += (contact.id -> contact)
  }

  def loadContact(idOpt: Option[Long]): ContactType = {
    idOpt match {
      case None =>
        val newContact = createContact(None)
        contacts += (newContact.id -> newContact)
        newContact
      case Some(id) =>
        contacts.get(id) match {
          case None => sys.error(s"Missing contact $id")
          case Some(contact) => contact
        }
    }
  }

  def removeFromContactList(owner: ContactType, contact: ContactType): Unit = {
    val updatedContacts = contactLists(owner.id).filter(id => id != contact.id)
    contactLists += (owner.id -> updatedContacts)
  }

  def addToContactList(owner: ContactType, newContact: ContactType): Unit = {
    contactLists.get(owner.id) match {
      case None =>
        contacts += (newContact.id -> newContact)
        contactLists += (owner.id -> List(newContact.id))
      case Some(existingContacts) =>
        contacts += (newContact.id -> newContact)
        contactLists += (owner.id -> (newContact.id :: existingContacts))
    }
  }

}

//@fragment
//trait MockContactsDAODyna extends MockContactsDAO {
//  this: ContactTypes =>
//}